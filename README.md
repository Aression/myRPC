# 从零开始的RPC实现

### version1 基础架构


### version2 引入Netty高性能网络通信框架

引入Netty高性能网络通信框架，实现客户端与服务端之间的通信。
在服务端和客户端分别通过Netty重新实现ServerHandler和ClientHandler，实现消息的编解码和业务逻辑处理。

### version3 引入Zookeeper服务注册与发现

引入zookeeper作为注册中心，实现服务注册与发现。服务端上线时，在注册中心注册自己的服务和对应地址；客户端启动时，从注册中心获取服务列表，并缓存到本地，后续调用时，从本地缓存中获取服务地址，进行远程调用。

特点：
- 高性能：全量数据存储在内存中，直接服务于客户端的所有非事务请求，尤其适用于读多写少的场景。
- 高可用：zookeeper一般以集群方式部署，即使单个节点故障，也不会影响整体服务。
- 严格顺序访问：对每个更新请求，zookeeper都会分配一个全局唯一的递增编号，保证顺序性。

使用方式：
- 在服务端的ServiceProvider中引入zookeeper，在provideServiceInterface方法注册服务时，同时向zookeeper提交服务信息
- 在客户端NettyRpcClient中，需要调用一个方法时，首先从zookeeper申请查询服务名对应的地址和端口，再进行请求操作
- 运行时，先在zookeeper安装目录的bin目录下打开zkServer.cmd把zookeeper服务跑起来，然后先后启动server和client

### version4 自定义序列化方法+性能对比

1. 在common包中实现自定义的编解码类，规定传输的数据包结构：

    ```
        /**
        * 消息结构如下:
        * +---------------+---------------+-----------------+-------------+
        * |  消息类型      |  序列化类型    |    数据长度      |    数据      |
        * |    2字节      |    2字节      |     4字节       |   N字节     |
        * +---------------+---------------+-----------------+-------------+
        * 
        * 1. 消息类型(2字节):
        *    - 0: RpcRequest请求消息
        *    - 1: RpcResponse响应消息
        * 
        * 2. 序列化类型(2字节):
        *    - 0: Java原生序列化
        *    - 1: JSON序列化
        * 
        * 3. 数据长度(4字节):
        *    - 标识序列化后的数据长度
        * 
        * 4. 数据(N字节):
        *    - 序列化后的消息体数据
        */
    ```

2. 实现ObjectSerializer和基于fastjson的ObjectSerializer方法；

3. 更新提供的用户服务以模拟实际的处理过程；
    - 遇到了rpc返回数据不能为空的问题，如果data字段为空则无法正常反序列化；解决方案是约定一个无效数据(id=-1)作为默认值。

4. 实现多节点的服务提供者和多线程混合读写的测试客户端，进行初步性能对比：
    - json：
        ```
        插入成功次数: 7011
        插入失败次数: 0
        删除成功次数: 1
        删除失败次数: 2988
        总耗时: 11826ms
        平均每秒处理数: 845.594452900389
        ```
    - object:
        ```
        插入成功次数: 7022
        插入失败次数: 0
        删除成功次数: 0
        删除失败次数: 2978
        总耗时: 10281ms
        平均每秒处理数: 972.6680284019064
        ```
    - protobuf:
        ```
        插入成功次数: 7047
        插入失败次数: 0
        删除成功次数: 0
        删除失败次数: 2953
        总耗时: 10211ms
        平均每秒处理数: 979.3360101850946
        ```

    对比结果：尽管操作更复杂，需要编写proto文件并预编译对应的消息类，但综合看来protobuf的性能最强

5. 使用Result<T>泛型包装返回消息，弃用原有的-1标识符以提升可维护性。