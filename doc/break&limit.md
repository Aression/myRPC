# 熔断和限流策略

在分布式系统或 RPC 框架中，服务间的调用可能会因为网络延迟、服务故障或突发流量等原因变得不稳定。为了保证核心服务的可用性和稳定性，防止故障扩散，熔断和限流是两种常用的保护机制。

## 熔断器 (Circuit Breaker)

熔断器模式可以防止应用程序重复尝试执行可能失败的操作。当某个服务的错误率超过阈值时，熔断器会"断开"，后续的请求将直接失败或返回预设的降级逻辑，而不会再去调用不稳定的服务，从而给下游服务恢复的时间。

### 实现原理

本项目中的熔断器 (`client.proxy.breaker.Breaker`) 基于一个简单的状态机实现，包含三种状态：

1.  **CLOSED (关闭):** 初始状态，允许所有请求通过。在此状态下，会持续监控请求的失败次数。
2.  **OPEN (开启):** 当失败次数达到预设阈值 (`failureThreshold`) 时，熔断器从 `CLOSED` 状态切换到 `OPEN` 状态。在此状态下，所有请求将被阻止，并快速失败。经过一段预设的恢复时间 (`retryTimePeriod`) 后，熔断器会进入 `HALF_OPEN` 状态。
3.  **HALF_OPEN (半开):** 在此状态下，熔断器允许少量请求通过，以探测下游服务是否已恢复。这些试探性请求的结果将被记录：
    *   如果成功率达到预设的 `half2OpenSuccessRate`，则认为服务已恢复，熔断器切换回 `CLOSED` 状态，并重置计数器。
    *   如果在 `HALF_OPEN` 状态下发生任何失败，熔断器将立即切换回 `OPEN` 状态，重新开始计时等待下一个恢复周期。

### 关键参数

*   `failureThreshold` (int): 在 `CLOSED` 状态下，触发熔断器切换到 `OPEN` 状态所需的连续或累计失败次数阈值。
*   `half2OpenSuccessRate` (double): 在 `HALF_OPEN` 状态下，判定服务恢复所需的成功请求比例（成功次数 / 总请求次数）。
*   `retryTimePeriod` (long): 熔断器处于 `OPEN` 状态后，进入 `HALF_OPEN` 状态尝试恢复的等待时间（以毫秒为单位）。

### 核心方法

*   `allowRequest()`: 在每次请求发起前调用，根据当前熔断器的状态判断是否允许该请求通过。
*   `recordSuccess()`: 当请求成功完成后调用。主要在 `HALF_OPEN` 状态下用于增加成功计数，并判断是否满足恢复条件以切换回 `CLOSED` 状态。
*   `recordFailure()`: 当请求失败后调用。用于增加失败计数。在 `CLOSED` 状态下，如果失败次数达到阈值，则切换到 `OPEN` 状态；在 `HALF_OPEN` 状态下，任何失败都会立即切换回 `OPEN` 状态。

### 线程安全

为了确保在并发环境下的正确性，熔断器内部使用了：

*   `AtomicInteger`: 对失败次数、成功次数和请求次数进行原子性操作。
*   `synchronized`: 对状态检查、状态转换以及计数器更新的关键方法 (`allowRequest`, `recordSuccess`, `recordFailure`) 进行同步控制，保证状态和计数的一致性。

## 限流器 (Rate Limiter)

限流器用于控制访问服务的速率，防止因瞬间流量过大导致服务过载甚至崩溃。通过限制单位时间内的请求数量，保证服务的平稳运行。

### 实现原理

本项目中的限流器 (`server.provider.ratelimit.impl.TokenBucketRateLimit`) 采用了 **令牌桶 (Token Bucket)** 算法。

令牌桶可以看作是一个固定容量的桶，系统会以恒定的速率向桶中放入令牌。当有请求到达时，需要先从桶中获取一个令牌才能被处理。如果桶中有足够的令牌，则请求通过；如果桶中没有令牌，则请求被拒绝或排队等待。

### 关键参数

*   `rate` (int): 令牌生成速率，在代码中体现为 `waitTimeRate`，表示生成一个新令牌所需的平均时间（以毫秒为单位）。例如，如果 `waitTimeRate` 为 100，则表示大约每秒生成 10 个令牌。
*   `capacity` (int): 令牌桶的最大容量 (`bucketCapacity`)。这决定了系统能够应对的突发流量的上限。即使没有请求消耗令牌，桶中的令牌数也不会超过此容量。

### 核心方法

*   `getToken()`: 尝试从令牌桶中获取一个令牌。
    1.  检查当前桶内是否有令牌 (`curCapacity > 0`)。如果有，则消耗一个令牌 (`curCapacity--`) 并返回 `true`。
    2.  如果桶内没有令牌 (`curCapacity == 0`)，则计算自上次成功获取令牌 (`lastAccessTime`) 以来，根据 `waitTimeRate` 应该生成多少新令牌。
    3.  将计算出的新令牌数（扣除当前请求消耗的一个）加入桶中，但不能超过桶的容量 `bucketCapacity`。
    4.  更新 `lastAccessTime` 为当前时间。
    5.  如果根据时间计算，可以生成并获取一个令牌，则返回 `true`；否则（即两次请求间隔小于 `waitTimeRate` 且桶已空），返回 `false`。

### 线程安全

令牌桶限流器的实现考虑了并发访问：

*   `volatile`: 使用 `volatile` 关键字修饰 `curCapacity` 和 `lastAccessTime`，确保多线程环境下的可见性。
*   `synchronized`: 对核心的 `getToken()` 方法进行同步，保证令牌的计算、增减和时间戳更新操作的原子性，防止并发冲突。

通过结合使用熔断器和限流器，可以有效提高 RPC 框架或分布式系统的健壮性和可用性。
