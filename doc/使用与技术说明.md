## 项目使用与技术说明（myRPC）

本文档面向首次接触本项目的使用者与维护者，涵盖环境准备、构建与运行、配置说明、架构与关键技术、故障排查与性能测试等内容。

### 1. 项目概览

- **项目名称**：myRPC（学习型 RPC 框架）
- **目标**：从零实现 RPC 的核心能力，包括高性能通信、服务注册发现、序列化协议、负载均衡、重试与熔断、服务端限流、日志与可观测性等。
- **主要模块（按源码目录）**：
  - `client`：客户端代理、重试、负载均衡、与服务中心交互。
  - `common`：协议编解码、消息模型、序列化、工具、结果包装、链路追踪（基础）。
  - `server`：服务暴露、注册、限流、Netty 服务端、Provider 端实现。
  - `src/main/proto`：`rpc.proto` 定义请求/响应消息（Protobuf）。

### 2. 运行环境与依赖

- **JDK**：11（`pom.xml` 中 `maven.compiler.source/target=11`）
- **构建工具**：Maven 3.6+
- **关键依赖**：
  - Netty 4.1.65.Final（高性能网络通信）
  - Apache Curator 5.1.0（基于 Zookeeper 的注册/发现）
  - Protobuf Java 3.21.7（高效序列化，与 `protoc` 保持一致版本）
  - Fastjson 1.2.83（可选 JSON 序列化）
  - guava-retrying 2.0.0（客户端重试）
  - slf4j 2.0.9 + logback 1.4.12（日志）
  - Caffeine 3.1.5（本地缓存，可用作客户端/注册中心地址缓存）
  - Jedis 4.4.3（可选：如需接入 Redis，用于外部缓存/数据存储）

### 3. 第三方服务准备

- **Zookeeper（必需）**：用于服务注册与发现。
  - 安装 Zookeeper 并启动：确保 `zkServer` 已运行，默认端口 2181。
  - 在 Windows 可使用官方二进制，或通过 Docker：
    ```bash
    docker run -d \
      -p 2181:2181 \
      --name zookeeper \
      zookeeper:3.8
    ```

- **Redis（可选）**：若使用到 Redis 相关功能（例如外部缓存），需先启动服务。
  - Docker 示例（来自 `doc/整体.md` 的注意事项）：
    ```bash
    docker run -d -p 6379:6379 --name redis_container redis
    ```

### 4. 构建与运行

1) 清理与编译
```bash
mvn -DskipTests clean package
```

2) 生成带依赖的可执行包（已在 `maven-assembly-plugin` 配置）
```bash
mvn -DskipTests package
```
生成物位于 `target/myRPC-1.0-SNAPSHOT-jar-with-dependencies.jar`。

3) 启动顺序
- 先启动 Zookeeper。
- 启动服务端：
  - 方式 A（IDE 运行）: 运行 `server.TestServer` 或 `server.MultiNodeServer`。
  - 方式 B（命令行）:
    ```bash
    java -Dfile.encoding=UTF-8 -cp target/myRPC-1.0-SNAPSHOT-jar-with-dependencies.jar server.TestServer
    ```
- 启动客户端：
  - 运行 `client.TestClient` 或并发压测 `client.ConcurrentTestClient`。

4) Protobuf 代码生成
- 项目已配置 `protobuf-maven-plugin`，默认从 `src/main/proto` 读取 `rpc.proto`，输出到 `src/main/java`。
- 若需重新生成：
```bash
mvn protobuf:compile
```

### 5. 配置说明

- 日志：使用 `src/main/resources/logback.xml`，输出至控制台与 `logs/rpc.log`（按日期滚动）。如需调整日志级别与路径，编辑该文件。
- SPI：在 `src/main/resources/META-INF/services` 注册以下扩展点实现：
  - `*.Serializer`：序列化实现（Java 原生、JSON、Protobuf）。
  - `*.LoadBalance`：负载均衡策略（随机、一致性哈希、序列/轮询、LSTM 拓展等）。
  - `*.RateLimit`：限流策略（令牌桶等）。
- 负载均衡选择：通过客户端 `ClientProxy` 构造或工厂切换（参考源码 `client/serviceCenter/balance`）。
- 注册中心：`client/serviceCenter/ZKServiceCenter` 与 `server/serviceRegister` 负责注册与发现，可配置 ZK 连接字符串、命名空间等（查看相应类的常量/构造参数）。
- 缓存：
  - 客户端本地缓存：如 `ZKCache`/Caffeine 缓存服务地址列表，降低对 ZK 的访问频率。
  - 可选外部缓存：如需使用 Redis，请在相关实现中配置连接。

### 6. 架构与数据流

1) 调用链路
- Client 侧：业务代码 -> `ClientProxy`（动态代理）-> 负载均衡选址 -> `RpcClient`（Netty/Socket）-> 编码（`Encoder`）-> 发送
- Server 侧：Netty Server -> 解码（`Decoder`）-> 路由到 `ServiceProvider` -> 执行业务 -> 结果封装 `Result<T>` -> 编码返回
- 注册中心：Server 启动时向 ZK 注册（`ZKServiceCenter`/`ServiceRegister`），Client 启动/首调/缓存失效时从 ZK 拉取并监听变更。

2) 协议与序列化
- 自定义消息头：
  - 消息类型（2B）：Request/Response
  - 序列化类型（2B）：Java/JSON/Protobuf
  - 数据长度（4B）
  - 数据（NB）
- 支持序列化：Java 序列化、Fastjson、Protobuf（性能最佳，建议在生产场景采用）。

3) 负载均衡
- 随机、轮询（或顺序）、一致性哈希（支持虚拟节点、变更监听自动重建哈希环）。
- Request 可携带“请求指纹/时间戳”等特征，便于一致性哈希获得稳定路由，提高缓存命中。

4) 客户端重试与熔断
- 重试：基于 guava-retrying，典型配置（等待 2s、最多 3 次，异常或 5xx 触发）。幂等性服务方可开启重试（由服务端在服务注册时标记）。
- 熔断：三态（CLOSED/OPEN/HALF_OPEN），关键参数：
  - `failureThreshold`：失败次数阈值
  - `half2OpenSuccessRate`：半开恢复所需成功率
  - `retryTimePeriod`：自 OPEN 至可半开的等待时长
- 判定：
  - `allowRequest()`：OPEN 且未到时间拒绝；到时间尝试 HALF_OPEN；CLOSED 直接允许。
  - `recordFailure()`：CLOSED 达阈值 -> OPEN；HALF_OPEN 任意失败 -> OPEN。
  - `recordSuccess()`：HALF_OPEN 成功率达标 -> CLOSED。
  - 实现参考：`client/proxy/breaker/CASBreaker.java`（基于 `AtomicReference`/CAS 保证并发正确性）。

5) 服务端限流
- 令牌桶（`server/provider/ratelimit/impl/*`）：
  - 参数：桶容量、补充速率/等待阈值、当前容量。
  - 行为：有令牌直接放行；无令牌根据时间差补充并限速，超过阈值返回 429。

6) 可观测性与日志
- 统一使用 slf4j + logback，核心日志位于 `logs/rpc.log` 和按日滚动文件（示例已存在）。
- 服务节点变更、熔断开合、重试与失败、限流命中等事件均有日志。

### 7. 快速上手示例

1) 启动服务端（单点）
```bash
# 确保 Zookeeper 已经运行
mvn -DskipTests package
java -Dfile.encoding=UTF-8 -cp target/myRPC-1.0-SNAPSHOT-jar-with-dependencies.jar server.TestServer
```

2) 启动客户端
```bash
java -Dfile.encoding=UTF-8 -cp target/myRPC-1.0-SNAPSHOT-jar-with-dependencies.jar client.TestClient
```

3) 多节点服务端
```bash
java -Dfile.encoding=UTF-8 -cp target/myRPC-1.0-SNAPSHOT-jar-with-dependencies.jar server.MultiNodeServer
```

### 8. 性能与对比（节选）

基于文档记录的样例数据（同一测试场景）：

- JSON：平均约 845 req/s
- Java 序列化：平均约 973 req/s
- Protobuf：平均约 979 req/s

结论：在本项目实现下，Protobuf 略优于 Java 序列化，均明显优于 JSON。实际性能受硬件、JVM 参数、Netty 配置、对象大小等影响。

### 9. 常见问题与排障

- 无法连接注册中心：检查 ZK 是否启动、连接串是否正确（端口 2181），以及客户端/服务端的 ZK 路径配置。
- 客户端调用被拒绝（429）：服务端限流触发。调大桶容量、降低请求速率，或优化服务端处理能力。
- 客户端快速失败：可能是熔断处于 OPEN。检查 `logs/rpc.log` 中熔断日志，等待 `retryTimePeriod` 或手动调整阈值。
- 反序列化失败/空数据：使用 `Result<T>` 包装响应，确保返回数据契约一致；若切换序列化方式需保证双方一致。
- Protobuf 版本不一致：`protoc` 与 `protobuf-java` 需版本匹配（本项目使用 3.21.7）。

### 10. 代码结构索引（关键类）

- 客户端
  - `client.proxy.ClientProxy`：动态代理、路由与调用
  - `client.serviceCenter.ServiceCenter` / `ZKServiceCenter`：服务发现与缓存
  - `client.serviceCenter.balance.*`：负载均衡策略与工厂
  - `client.rpcClient.impl.*`：传输实现（Netty/Socket）
  - `client.proxy.breaker.CASBreaker`：熔断器（CAS 并发安全）

- 服务端
  - `server.provider.ServiceProvider`：服务注册与暴露
  - `server.serviceRegister.*`：服务注册逻辑
  - `server.provider.ratelimit.*`：限流实现（令牌桶）
  - `server.TestServer` / `server.MultiNodeServer`：示例服务端启动器

- 公共
  - `common.Encoder` / `common.Decoder`：自定义协议编解码
  - `common.message.*`：消息体与 Protobuf 生成代码
  - `common.serializer.*`：序列化接口与实现（含 `ProtobufSerializer`）
  - `common.result.Result`：统一结果包装
  - `common.util.*`：工具集（如 `HashUtil`、`AddressUtil`）

### 11. 约定与最佳实践

- 生产环境建议：
  - 使用 Protobuf 序列化；
  - 开启并合理配置熔断、重试（仅幂等接口）、限流；
  - 对 ZK 连接、会话超时与本地缓存进行优化；
  - 结合 metrics/trace（可扩展至 Prometheus/Zipkin 等）。
- 单测与压测：
  - 使用 `client.ConcurrentTestClient` 做并发调用对比；
  - 使用 `target/surefire-reports` 中的测试报告回看结果。

### 12. 版本与演进（摘要）

- v2：引入 Netty
- v3：引入 Zookeeper 注册/发现
- v4：自定义编解码与多序列化（含 Protobuf）
- v5：一致性哈希负载均衡、ZK 缓存监听
- v6：幂等性重试、客户端熔断、服务端令牌桶限流、日志完善

---

如需进一步扩展（鉴权、TLS、安全限流、链路追踪完善、隔离/舱壁等），可在现有 SPI 与模块化基础上逐步演进。


